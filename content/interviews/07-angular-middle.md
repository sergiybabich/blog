---
title: По живому наживо №7. Angular Middle, Іван Разнатовський

date: 2022-05-29T12:00:00+03:00

type: interview
---
{{< youtube 7HHYOsIWnpk >}}
--

## JavaScript
### Поясніть концепцію замикань в JavaScript. Наведіть приклад того, як замикання можуть використовуватися для інкапсуляції даних та створення приватних змінних в функції.
Замикання --- це функція, яка зберігає посилання на змінні з зовнішньої області видимості, навіть після того, як функція виконана. Це дозволяє зберігати стан між викликами функції та використовувати цю функцію для інкапсуляції даних та створення приватних змінних.
 
### Опишіть різницю між синхронним та асинхронним JavaScript. Як ви обробляєте асинхронні операції за допомогою зворотних викликів (callbacks), промісів (promises) або async/await?
Синхронний JavaScript виконує код послідовно, один за одним. Кожна операція чекає завершення попередньої операції, перед тим як почати своє виконання. Це означає, що коли виконується синхронний код, програма "блокується", і виконання будь-яких інших дій зупиняється до закінчення поточної операції.

Асинхронний JavaScript, навпаки, не блокує програму виконанням окремих операцій. Замість цього, він дозволяє виконувати деякі операції паралельно, не чекаючи їх завершення перед переходом до наступних дій. Асинхронні операції виконуються в фоновому режимі, і код продовжує своє виконання без очікування їх закінчення.

#### Обробка асинхронних операцій:
##### Зворотні виклики (Callbacks):
```js
function fetchData(callback) {
  setTimeout(() => {
    const data = 'Some data fetched';
    callback(data);
  }, 2000);
}

function processData(data) {
  console.log(data);
}

fetchData(processData);
```
##### Проміси (Promises):
```js
function fetchData() {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      const data = 'Some data fetched';
      resolve(data);
    }, 2000);
  });
}

fetchData()
  .then(data => console.log(data))
  .catch(error => console.error(error));
```
##### async/await:
```js
function fetchData() {
  return new Promise((resolve) => {
    setTimeout(() => {
      const data = 'Some data fetched';
      resolve(data);
    }, 2000);
  });
}

async function getData() {
  try {
    const data = await fetchData();
    console.log(data);
  } catch (error) {
    console.error(error);
  }
}

getData();
```

У всіх трьох підходах ми можемо ефективно обробляти асинхронні операції. Зворотні виклики використовують функції зворотного виклику для обробки результатів асинхронних дій. Проміси дозволяють робити послідовні ланцюжки дій з .then() та обробляти помилки з .catch(). async/await є синтаксичним цукром над промісами, що дозволяє писати асинхронний код в синхронному стилі, забезпечуючи читабельність та зручність у обробці асинхронних операцій.

### Що таке генератори (generators) в JavaScript, і в чому вони відрізняються від звичайних функцій? Наведіть приклад використання генератора для створення ітерабельної послідовності.
Генератори --- це функції, які дозволяють призупиняти своє виконання та повертати проміжні значення під час виконання. Вони відрізняються від звичайних функцій тим, що можуть бути призупинені у будь-який момент та відновлені з попереднього стану. Коли генератор викликається, він не виконується в повному обсязі, а повертає об'єкт генератора (generator object), який може ітерувати через значення, відповідні директиві yield.

```js
function* generateSequence() {
  yield 1;
  yield 2;
  yield 3;
}

const generator = generateSequence();

console.log(generator.next().value); // 1
console.log(generator.next().value); // 2
console.log(generator.next().value); // 3
```
### В чому полягає різниця між прототипним наслідуванням та класичним наслідуванням в JavaScript. Поясніть, коли б ви використали кожен підхід, а також їхні плюси та мінуси.
#### Прототипне наслідування в JavaScript
Прототипне наслідування в JavaScript використовує механізм прототипів для передачі властивостей та методів від одного об'єкта (прототипу) до іншого об'єкта. Кожен об'єкт має посилання на свій прототип, і якщо властивість або метод не знаходиться в об'єкті, пошук продовжується вгору по ланцюжку прототипів.

#### Класичне наслідування в JavaScript
Класичне наслідування в JavaScript базується на використанні конструкторів та ключового слова new для створення нових об'єктів, які успадковують властивості та методи від батьківських класів. Використання класів і конструкторів дає змогу створювати більш явну та декларативну структуру коду.

#### Коли використовувати прототипне наслідування
Прототипне наслідування може бути корисним, коли необхідно створити багато об'єктів, які мають спільні методи та властивості. Воно дозволяє зменшити дублювання коду і забезпечити зручний механізм для збереження спільних характеристик об'єктів.

##### Плюси прототипного наслідування
- Зменшення дублювання коду через спільне використання методів та властивостей в прототипі.
- Простота динамічного змінювання та додавання властивостей і методів під час виконання.

##### Мінуси прототипного наслідування
- Може призвести до незрозумілості і складності, коли об'єкти мають складний ланцюжок прототипів.
- Не підтримує інкапсуляцію та захист приватних даних.

#### Коли використовувати класичне наслідування
Класичне наслідування може бути більш зручним, коли потрібно створити чітку ієрархію об'єктів з визначеними класами і методами. Воно дозволяє використовувати ключове слово extends для наслідування властивостей та методів з батьківських класів.

##### Плюси класичного наслідування 
- Чітка структура коду з використанням класів і конструкторів.
- Збільшує зрозумілість коду та полегшує обслуговування.

##### Мінуси класичного наслідування
- Можливі проблеми з дублюванням коду при багатьох рівнях успадкування.
- Не підтримує динамічні зміни структури об'єктів.

Вибір між прототипним та класичним наслідуванням залежить від конкретної ситуації і потреб вашого проекту. Кожен підхід має свої переваги та обмеження, і правильний вибір може покращити розробку та обслуговування коду.
 
### Що таке модулі (modules) в JavaScript, і як вони сприяють кращій організації та інкапсуляції коду?
Модулі в JavaScript --- це механізм організації коду, який дозволяє розділити функціональність на окремі, незалежні одиниці. Кожен модуль має свій внутрішній стан та імплементацію, а також інтерфейс, який визначає, як інші модулі можуть взаємодіяти з ним. Модулі забезпечують інкапсуляцію, тобто деталі реалізації приховуються, і зовнішній світ може використовувати лише публічний інтерфейс модуля.

#### Користь модулів в JavaScript
- **Організація коду**: Модулі допомагають організувати великі проекти в окремі, логічно пов'язані частини, що полегшує управління та розробку.
- **Інкапсуляція**: Публічні та приватні методи та змінні дозволяють приховати деталі реалізації модуля, зберігаючи тільки те, що потрібно для зовнішнього використання.
- **Повторне використання**: Модулі можуть бути використані на різних місцях проекту та навіть в інших проектах, забезпечуючи повторне використання коду.

## Розробка на Angular
### Як ви вирішуєте проблему взаємодії між компонентами в Angular? Поясніть сценарії, коли ви використовували б @Input, @Output, ViewChild та сервіси для взаємодії між компонентами.
Angular надає кілька механізмів для взаємодії між компонентами в додатку:

#### @Input та @Output декоратори
Сценарії використання @Input:
  * Передача даних від батьківського компонента до дочірнього компонента.
  * Конфігурування дочірнього компонента зовнішніми параметрами.

Сценарії використання @Output
  * Передача даних від дочірнього компонента до батьківського компонента за допомогою подій (EventEmitter).
  * Зворотний зв'язок з дочірнього компонента до батьківського компонента після певної дії.

#### ViewChild декоратор
Сценарії використання ViewChild:
  * Отримання доступу до дочірнього компонента або DOM-елементів з розмітки для здійснення змін або отримання даних.
  * Взаємодія з методами або властивостями дочірнього компонента без необхідності прямого взаємодії через сервіси.

#### Сервіси
Сценарії використання сервісів:
  * Обмін даними між компонентами, які не мають прямого батьківсько-дочірнього відношення.
  * Збереження та обробка спільних даних та стану між компонентами.
  * Реалізація взаємодії між компонентами, яка не обмежена ієрархією компонентів.

#### Приклади використання
##### @Input, @Output
```ts
// ParentComponent
<app-child [inputData]="data" (outputEvent)="handleEvent($event)"></app-child>

// ChildComponent
@Input() inputData: any;
@Output() outputEvent: EventEmitter<any> = new EventEmitter();

// ...

// ViewChild:
@ViewChild(ChildComponent) childComponent: ChildComponent;
```

##### Сервіси
```ts
// DataService
import { Injectable } from '@angular/core';

@Injectable()
export class DataService {
  sharedData: any;

  setData(data: any) {
    this.sharedData = data;
  }

  getData() {
    return this.sharedData;
  }
}

// Component1
import { Component } from '@angular/core';
import { DataService } from './data.service';

@Component({...})
export class Component1 {
  constructor(private dataService: DataService) {}

  sendDataToService() {
    this.dataService.setData({ name: 'John', age: 30 });
  }
}

// Component2
import { Component } from '@angular/core';
import { DataService } from './data.service';

@Component({...})
export class Component2 {
  constructor(private dataService: DataService) {}

  receiveDataFromService() {
    const data = this.dataService.getData();
    console.log(data); // { name: 'John', age: 30 }
  }
}
```

### Опишіть концепцію директив (directives) в Angular та їхні використання. Наведіть приклади вбудованих директив та сценаріїв, коли ви створили б власні директиви.
Директиви в Angular --- це класи, які розширюють функціональність HTML елементів або шаблонів. Вони дозволяють нам змінювати поведінку та вигляд DOM елементів. Angular надає два типи директив: атрибутивні та структурні.

**Атрибутивні директиви** маніпулюють атрибутами DOM елементів. Вони додають або змінюють певні атрибути, такі як ngStyle, ngClass, або власні директиви.

**Структурні директиви** змінюють структуру DOM. Вони додають або видаляють елементи з DOM, такі як ngIf, ngFor, або власні директиви.

```ts
// *ngIf:
<div *ngIf="showMessage">
  Повідомлення буде видимим, якщо showMessage === true
</div>

//*ngFor:
<ul>
  <li *ngFor="let item of items">{{ item }}</li>
</ul>

//*ngSwitch:
<div [ngSwitch]="color">
  <p *ngSwitchCase="'red'">Це червоний колір</p>
  <p *ngSwitchCase="'blue'">Це синій колір</p>
  <p *ngSwitchDefault>Це інший колір</p>
</div>
```
#### Користувацькі директиви:

```ts
// Атрибутивна директива
import { Directive, ElementRef } from '@angular/core';

@Directive({
  selector: '[appHighlight]'
})
export class HighlightDirective {
  constructor(private el: ElementRef) {
    el.nativeElement.style.backgroundColor = 'yellow';
  }
}
...
<p appHighlight>Цей текст буде виділений жовтим фоном</p>
```
```ts
// Структурна директива:
import { Directive, Input, TemplateRef, ViewContainerRef } from '@angular/core';

@Directive({
  selector: '[appUnless]'
})
export class UnlessDirective {
  @Input() set appUnless(condition: boolean) {
    if (!condition) {
      this.vcRef.createEmbeddedView(this.templateRef);
    } else {
      this.vcRef.clear();
    }
  }

  constructor(private templateRef: TemplateRef<any>, private vcRef: ViewContainerRef) {}
}
...
<div *appUnless="showContent">Цей контент буде відображений, якщо showContent === false</div>
```
Використання вбудованих директив дозволяє легко змінювати поведінку та вигляд елементів на сторінці без необхідності писати багато JavaScript коду. А створення власних директив дозволяє розширити функціональність додатку та створити перевикористовуваний код для комплексних взаємодій з DOM елементами.

### Поясніть механізм виявлення змін (change detection) в Angular та оптимізацію для покращення продуктивності додатка.
Виявлення змін --- це процес, за допомогою якого Angular визначає, які дані або стан змінилися в додатку та оновлює відповідні DOM елементи. Коли стан додатку змінюється, Angular перевіряє компоненти, директиви та їхні шаблони, щоб визначити, які елементи потрібно оновити в DOM.

#### Оптимізація для покращення продуктивності додатка
1. **Використання імутабельних даних**: Використовуйте імутабельні (незмінні) структури даних, такі як *Immutable.js* або *RxJS*, для уникнення непотрібних перевірок змін.
2. **Зміна детекції на OnPush**: Встановіть стратегію виявлення `ChangeDetectionStrategy.OnPush` для компонентів, які очікуєте на зміни тільки вхідних даних або внутрішнього стану, що змінюється в компоненті. Це дозволить Angular перевіряти зміни тільки для таких компонентів, що дозволяє зменшити обсяг виявлення змін.
3. **Використання асинхронних операцій**: Використання асинхронних операцій, таких як `async/await` або `rxjs`, дозволяє уникати блокування потоку виконання та зменшити кількість перевірок змін.
4. **Ліниве завантаження**: Використовуйте ліниве завантаження модулів для завантаження компонентів тільки тоді, коли вони потрібні, що дозволить зменшити навантаження на стартовому завантаженні додатка.
5. **Використання трекера змін**: Використовуйте `ChangeDetectorRef.detectChanges()` для явного виклику механізму виявлення змін, коли зміни стануть відомі за межами зони виявлення.
6. **Memoization**: Використання мемоізації для збереження результатів обчислень та уникнення повторних обчислень.
7. **Використання trackBy**: Використовуйте trackBy в `ngFor` для ідентифікації унікальних елементів списку та зменшення перерисування DOM елементів при змінах.
8. **Змінні для вхідних даних**: Зберігайте вхідні дані у змінних та використовуйте їх в шаблоні. Таким чином, Angular не вимагатиме звернення до геттерів вхідних даних, що зменшить кількість перевірок.
9. **Використання Web Workers**: Використання Web Workers для виконання важких обчислень асинхронно та унікальних для DOM в окремому потоці, що не впливає на головний потік.

### Що таке HttpClient в Angular, і як його використовувати для здійснення API-викликів у додатку на Angular? Обговоріть обробку помилок та роботу з Observable при використанні HttpClient.
HttpClient в Angular --- це модуль, який надає можливість здійснювати HTTP запити до сервера та отримувати відповіді в додатку на Angular. Він надає простий та зручний інтерфейс для виконання різних типів запитів, таких як GET, POST, PUT, DELETE, тощо.

#### Використання HttpClient для API-викликів
Для початку використання HttpClient, спочатку імпортуємо його в сервіс або компонент:

```ts
import { HttpClient } from '@angular/common/http';
```
Потім інжектимо HttpClient в конструктор класу:

```ts
constructor(private http: HttpClient) { }
```
Тепер можна здійснювати API-виклики. Наприклад, для отримання даних за допомогою GET запиту:

```ts
getData() {
  return this.http.get('https://api.example.com/data');
}
```
#### Обробка помилок та робота з Observable
При використанні HttpClient, результат виклику методів повертається у вигляді Observable. Ми можемо підписатися на цей Observable та отримати дані або обробити помилки.

```ts
getData() {
  return this.http.get('https://api.example.com/data').pipe(
    catchError((error) => {
      // Обробка помилки
      console.error('Сталася помилка при отриманні даних:', error);
      return throwError('Щось пішло не так, спробуйте пізніше');
    })
  );
}
```
У випадку, якщо запит не вдалося виконати, ми можемо обробити помилку, вивести її в консоль та повернути відповідний текст помилки.

При підписці на Observable, ми можемо виконати дії при успішному отриманні даних та обробити помилки:

```ts
this.getData().subscribe(
  (data) => {
    // Обробка отриманих даних
    console.log('Отримані дані:', data);
  },
  (error) => {
    // Обробка помилки
    console.error('Сталася помилка:', error);
  }
);
```
Таким чином, використання HttpClient дозволяє легко здійснювати API-виклики та обробляти дані та помилки з сервера за допомогою Observable.

### Як ви вирішуєте задачу валідації форм в Angular? Поясніть різницю між формами на основі шаблонів (template-driven) та реактивними формами (reactive forms) і в яких випадках ви обираєте кожен підхід.
При вирішенні задачі валідації форм в Angular, можна використовувати два підходи: **форми на основі шаблонів (template-driven forms)** та **реактивні форми (reactive forms)**.

#### Форми на основі шаблонів (Template-Driven Forms)
- Це простий і швидкий спосіб створення форм в Angular.
- Валідація задається безпосередньо в шаблоні HTML за допомогою директив Angular, таких як `ngModel`, `ngModelGroup`, `ngForm`, тощо.
- Дозволяє легко створювати форми для простих випадків без необхідності писати багато коду.
Валідація відбувається автоматично на основі HTML атрибутів, таких як `required`, `minlength`, `maxlength`, тощо.
- Підходить для простих форм без складної логіки валідації.

#### Реактивні форми (Reactive Forms):
- Це більш потужний і гнучкий підхід для створення форм в Angular.
- Валідація визначається програмно за допомогою TypeScript коду, що дозволяє здійснювати більш складні перевірки та використовувати кастомні валідатори.
- Дозволяє створювати динамічні форми зі змінюваним набором полів.
- Пропонує більшу контроль над формами та даними, що дозволяє зручно взаємодіяти з формами в коді компонентів.
- Підходить для складних форм з потребою валідації залежно від стану додатку та інших факторів.

#### Вибір підходу
- Якщо форма проста, має мінімальну логіку валідації та швидкої розробки, форми на основі шаблонів (template-driven forms) можуть бути швидшим варіантом.
- Якщо форма складніша, має вимоги до більшої контролю над валідацією та динамічного створення полів, то реактивні форми (reactive forms) будуть більш підходящим варіантом.
- Крім того, якщо необхідно перевикористовувати компоненти з формами та забезпечити їхню розширюваність, реактивні форми можуть бути кращим варіантом.

Загалом, обираючи між двома підходами, слід враховувати складність та особливості форми, потребу валідації та контролю, а також комфорт роботи з кожним підходом для конкретного випадку.

### Як працює Dependency Injection (DI) в Angular? Поясніть переваги використання DI та як він допомагає з взаємодією між компонентами та підтримкою коду.
Dependency Injection (DI) – це патерн, який використовується в Angular для постачання залежностей (об'єктів, сервісів, компонентів) в компоненти або сервіси в час виконання. Замість того, щоб створювати залежності вручну в коді, Angular автоматично впроваджує залежності, необхідні для компонентів, підставляючи їх із заздалегідь визначених провайдерів.

#### Переваги використання Dependency Injection в Angular
1. **Розділення відповідальностей**: DI допомагає зберігати код чистим і розділеним на окремі компоненти та сервіси. Кожен компонент відповідає за свою окрему функціональність, а DI допомагає впроваджувати необхідні сервіси, що забезпечують цю функціональність.
2. **Перевикористання коду**: Завдяки DI, сервіси можна перевикористовувати у різних компонентах і модулях, що зменшує дублювання коду і сприяє кращій підтримці.
3. **Легше тестування**: DI спрощує тестування компонентів, оскільки можна замінювати реальні залежності на мок-об'єкти або зручні для тестів провайдери.
4. **Зменшення залежності**: Компоненти не повинні залежати від конкретних реалізацій, а лише від абстракцій, що спрощує зміну і покращення коду.
5. **Легший рефакторинг**: Завдяки DI, можна легко змінювати логіку та реалізацію залежностей, не впливаючи на код компонентів.

#### Взаємодія між компонентами та підтримка коду
DI дозволяє зручно взаємодіяти між компонентами та іншими частинами додатка, забезпечуючи доступ до об'єктів та сервісів, які вони потребують. Коли компонент або сервіс створюється, Angular шукає його залежності в провайдерах та автоматично впроваджує їх. Це дозволяє легко змінювати поведінку додатка шляхом заміни або розширення залежностей.

Наприклад, якщо ми маємо сервіс для зберігання даних, всі компоненти, які потребують доступ до цих даних, можуть отримати доступ до цього сервісу за допомогою DI. Це дозволяє забезпечити єдиний джерело даних для додатка та підтримувати легку взаємодію між компонентами.

Загалом, Dependency Injection в Angular допомагає зберігати код організованим, підтримуваним та легко тестируємим, а також забезпечує зручну взаємодію між компонентами та іншими частинами додатка.


## Тестування
### Що саме ми можемо тестувати за допомогою юніт-тестів?

У конпонентах фронтенду є декілька аспектів, які можна протестувати за допомогою юніт-тестів. Ось декілька ключових розділів для тестування:

1. **Рендерінг і відображення:** Перевірка того, як компонент рендериться та відображається на сторінці. Це може включати перевірку правильності відображення тексту, зображень, класів CSS тощо.

2. **Взаємодія:** Перевірка реакції компонента на взаємодію користувача, таку як кліки, введення тексту та інші події. Переконайтеся, що компонент правильно реагує на ці події та виконує очікувані дії.

3. **Стан:** Тестування зміни внутрішнього стану компонента та перевірка, як він впливає на його відображення та поведінку. 

4. **Пропси:** Перевірка передачі пропсів (властивостей) в компонент та їх правильності обробки.

5. **Логіка бізнес-логіки:** Тестування функцій та методів, які реалізують бізнес-логіку вашого компонента. 

6. **Мережева взаємодія:** Якщо ваш компонент взаємодіє з сервером через API, перевірте, як він обробляє різні відповіді сервера та помилки.

7. **Роутінг:** Якщо ви використовуєте маршрутизацію в своєму додатку, перевірте, як компоненти взаємодіють з роутами та параметрами URL.

Загалом, мета юніт-тестування полягає в перевірці окремих одиниць вашого коду на відповідність специфікаціям та очікуваній поведінці. Це допомагає підтримувати стабільність вашого коду під час змін і вдосконалень, а також полегшує виявлення та виправлення помилок.

## Git
### Уявіть, що ви співпрацюєте з командою розробників у проекті, використовуючи Git. Один з членів команди випадково закомітив чутливу інформацію, таку як API-ключі або паролі, у репозиторій. Як ви реагуватимете на таку ситуацію, щоб уникнути витоку чутливої інформації у Git-історії?
У такій ситуації, щоб уникнути витоку чутливої інформації у Git-історії, я вживу такі дії:

1. Негайно повідомлю про виявлення чутливої інформації всіх членів команди та керівництва проекту.

2. Перевірю всі активні гілки репозиторію, щоб забезпечити, що чутливі дані не потрапили в інші гілки.

3. Виконаю команду `git rm --cached` для видалення файлів з чутливою інформацією з індексу (staged changes).

4. Зроблю зміни у файлі `.gitignore`, щоб забезпечити, що файли з чутливою інформацією не будуть більше враховуватись Git.

5. Застосую `git commit --amend` для перезапису останнього коміту без чутливих даних. 

6. Виконаю команду `git push --force` для оновлення віддаленого репозиторію і видалення чутливої інформації з історії комітів.

7. Зміню паролі та ключі доступу, які можуть бути скомпрометовані, та повідомлю всіх зацікавлених сторін про зміну доступу.

8. Надам інструкції та навчання команді щодо належного управління чутливою інформацією та правилам безпеки Git.

9. Ретельно перевірю усю історію репозиторію на наявність інших чутливих даних та забезпечу, щоб подібні ситуації не повторилися.

Ці дії допоможуть вчасно врегулювати ситуацію та запобігти можливим наслідкам, пов'язаним з витоком чутливої інформації.

### В робочому процесі з використанням Git, як ви вирішуєте конфлікти, які виникають, коли декілька членів команди працюють одночасно над одним файлом? Наведіть приклади інструментів та стратегій, які ви використовуєте для ефективного вирішення конфліктів.
При вирішенні конфліктів, що виникають при одночасній роботі декількох членів команди над одним файлом в Git, я використовую такі інструменти та стратегії:

1. Використання візуалізаційних інструментів: Зазвичай я використовую інтегровані редактори Git, такі як GitKraken або SourceTree, що дозволяють зручно вирішувати конфлікти, порівнюючи зміни та обираючи вірні варіанти.

2. Мерджі і ребейзи: Я практикую часті коміти та мерджі або ребейзи перед злиттям у головну гілку. Це допомагає зменшити кількість конфліктів та зробити їх легше вирішувати.

3. Комунікація в команді: Важливо попереджати колег про свої наміри змінити певний файл, особливо, якщо це великий або складний файл. Таким чином, ми можемо уникнути ситуації, коли декілька людей вносять зміни в одні й ті самі рядки коду одночасно.

4. Використання бранчів: Я використовую бранчі для роботи над окремими функціональними частинами. Це дозволяє знизити ймовірність конфліктів, оскільки робота над різними частинами коду відбувається паралельно.

Приклад вирішення конфлікту:

Припустимо, що у двох різних бранчах "featureA" та "featureB" були внесені зміни до одного і того ж рядка коду. При мерджі цих бранчів виникне конфлікт. Відкрию файл, де виник конфлікт, в редакторі GitKraken, позначу зміни з обох гілок та оберу вірний варіант або об'єдную зміни так, щоб вони взаємодіяли коректно. Після цього збережу файл та закомічу зміни. Після успішного мерджу можу продовжити роботу над проектом.

Ці стратегії допомагають підтримувати ефективну співпрацю в команді та ефективно вирішувати конфлікти, що можуть виникати під час роботи з Git.

## Перевірка коду --- Принципи SOLID
### Під час перевірки коду ви стикаєтесь з ділянкою коду, де, схоже, не дотримуються принципи SOLID. Які конкретні проблеми або порушення принципів ви виявляєте в коді, що допомагають вам зробити такий висновок? Поясніть, як можна переписати код так, щоб він відповідав принципам SOLID.
Під час перевірки коду на виконання принципів SOLID, я зазвичай звертаю увагу на наступні проблеми або порушення принципів:

1. Принцип єдиного обов'язку (Single Responsibility Principle --- SRP):
- Виявлення класів або функцій, які мають занадто багато обов'язків та роблять різні операції.
- Різноманітність логіки в одному класі, яка могла б бути розділена на окремі класи.

2. Принцип відкритості/закритості (Open/Closed Principle --- OCP):
- Виявлення коду, який не зручно розширювати для внесення нових змін без зміни самого коду.
- Використання умовних операторів, які роблять код крихким, тобто будь-яка зміна може привести до великої кількості помилок.

3. Принцип підстановки Лісков (Liskov Substitution Principle --- LSP):
- Виявлення підкласів, які не можуть повністю замінити базовий клас без збою.

4. Принцип розділення інтерфейсу (Interface Segregation Principle --- ISP):
- Виявлення інтерфейсів, які мають занадто багато методів, що може призводити до непотрібної залежності класів від методів, які не використовуються.

5. Принцип інверсії залежності (Dependency Inversion Principle --- DIP):
- Використання жорстких залежностей в коді, які утруднюють тестування та перевикористання коду.

Для переписання коду таким чином, щоб він відповідав принципам SOLID, я можу виконати наступні кроки:

1. Розділити класи або функції на окремі компоненти з єдиним обов'язком.
2. Виділити загальну логіку у базовий клас та дозволити його розширювати для впровадження нових функціональних можливостей.
3. Забезпечити, щоб підкласи повністю заміняли базовий клас та дотримувалися його контракту.
4. Розділити інтерфейси на менші, специфічні для клієнтів, та забезпечити, щоб класи реалізували тільки ті методи, які їм потрібні.
5. Застосовувати зворотні залежності через Dependency Injection, щоб зменшити залежність класів від конкретних реалізацій.

Ці кроки допоможуть зберегти принципи SOLID у коді, що забезпечить більшу зрозумілість, гнучкість та підтримку кодової бази.